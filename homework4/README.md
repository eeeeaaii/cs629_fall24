# Homework 4: Ray Tracer

You will complete the implementation of a raytracer,
as discussed in class and in your book. Your raytracer will render one scene as a still image, using `Frame`, `Renderer`, and `Color` classes, like in homework 3. The code for the renderer will be in the `renderer` folder, as before.

The files that you will need to complete are:
```
raytracer.cpp
sphere.cpp
triangle.cpp
```


At startup, your raytracer will read in a configuration file that contains all the information about what is in the scene. The code for parsing that configuration file will be provided to you, so you can focus on the raytracing part. The code for doing this is in the `configfile` folder.

You also have a vector class you can use with the standard vector operations (in the `vect` folder).

You will also be provided a set of 12 example files and output PNGs showing what the raytracer should display when run with that configuration file. These are the same files that will be used for grading your assignment. I will be looking at your source code also, to make sure you really wrote a raytracer.

Note that only examples 1-9 are required. The rest (10, 11, and 12) are optional/extra credit (see below).

I recommend that you put all your source code in the src folder, and that you don't make any changes to the code in the `renderer` or `configfile` folders.

Your raytracer needs to support the following entity types:

* spheres
* triangles
* point lights
* directional lights (one per scene)

And the following lighting calculations:
* ambient
* diffuse
* specular

The focal length of your raytracer will be passed in via the config file -- this part will be done for you.

Some notes:
* If you read about the fact that lights can have their own color, or specular reflections can have color, don't worry about that. The only thing that will have color is diffuse and ambient reflections, everything else is white.
* The amount of specular lighting on a given surface is controlled by a coefficient from 0-1 called glossiness. After doing the specular calculation from the notes, you multiply by the glossy coefficient. Full glossy means that the coefficient is 1 and you get the entire specular term. No glossiness means that there are no specular reflections.
* The amount of diffuse reflection is just controlled by the color you are using for diffuse/ambient lighting (use a darker color for objects that have few diffuse reflections).
* directional lights are specified with a vector that tells you the direction the light is shining.

## Config file

Even though the config files are provided for you, I recommend you take a look at them.

### Parsed Data

The data that is parsed by the config file will be returned back to you from the parse method in the format defined in `configfile/scenedata.h`

## Drawing API

The drawing API is exactly the same as your line drawing assignment.


## Debugger

I've given you a debugger class. To use the debugger, anywhere in your code that you want to debug something, type:

```
DEBUGGER.set_value(some_number)
```

You may have to also import the debugger, i.e.:

```
extern Debugger DEBUGGER;
```

The debugger is meant to be used in your code that is drawing a different thing for every pixel on the screen. When you call `set_value`, it will set the value for that specific pixel, so you will get a "debug image" that has values from black to white, showing what the debug value was for each point in the image.

If you set values that are less than 0, or greater than 1, the debugger will scale them so the largest values are white and the smallest values are black.

If you don't set any values, the debugger will not appear and you'll just see the real image that your raytracer is drawing.

A scenario where you might use the debugger might be like this:
1. You're trying to write your shader code but it's not have the effect you want.
2. You insert calls to `set_value`, and instead of seeing your output image, you see an image generated by the debugger, with the value you passed to `set_value` in every pixel.
3. By looking at the greyscale image, you are able to figure out what's going wrong, and you fix your code.
4. You remove the call to `set_value`, and now your picture is rendering again.


## Optional Extra Credit

Your raytracer is not required to perfect (mirror) reflections, or shadows. If you want to implement those too, you can, for extra credit. The example file for mirror reflections (example 12) is rendered with 5 bounces.
